// Part of the byte-knight project.
// Author: Paul Tsouchlos (ptsouchlos) (developer.paul.123@gmail.com)
// GNU General Public License v3.0 or later
// https://www.gnu.org/licenses/gpl-3.0-standalone.html

use std::fmt::Display;

use arrayvec::ArrayVec;

/// A generic 2D table for general use in chess engines.
#[derive(Debug, Clone)]
pub(crate) struct Table<T, const CAP: usize> {
    data: ArrayVec<T, CAP>,
    width: usize,
    height: usize,
}

impl<T, const CAP: usize> Table<T, CAP> {
    /// Creates a new table with the specified width and height.
    /// The table is initialized with a capacity of `CAP` elements.
    /// The width and height are the number of columns and rows respectively.
    ///
    /// # Arguments
    ///
    /// - `width` - The number of columns in the table.
    /// - `height` - The number of rows in the table.
    ///
    /// # Returns
    ///
    /// A new instance of `Table<T, CAP>`.
    ///
    /// # Panics
    ///
    /// This function will panic if width*height > CAP.
    pub fn new(width: usize, height: usize) -> Self {
        assert!(
            width * height <= CAP,
            "Table capacity exceeded: {} > {}",
            width * height,
            CAP
        );

        Self {
            data: ArrayVec::<T, CAP>::new(),
            width,
            height,
        }
    }

    /// Insert an element at the given row and column.
    ///
    /// # Arguments
    ///
    /// - `value` - The value to insert.
    /// - `row` - The row index.
    /// - `col` - The column index.
    pub fn insert(&mut self, value: T, row: usize, col: usize) {
        assert!(
            row < self.rows() && col < self.cols(),
            "Invalid row or column index"
        );
        self.data.insert(self.index(row, col), value);
    }

    /// Get a mutable reference to the element at the given row and column, if it exists.
    ///
    /// # Arguments
    ///
    /// - `row` - The row index.
    /// - `col` - The column index.
    ///
    /// # Returns
    ///
    /// An `Option<&T>` that contains a reference to the element at the specified row and column, or `None` if it does not exist.
    pub fn at(&self, row: usize, col: usize) -> Option<&T> {
        self.data.get(self.index(row, col))
    }

    /// Get a slice of the given row.
    ///
    /// # Arguments
    ///
    /// - `row` - The row index.
    ///
    /// # Returns
    ///
    /// A slice of the row at the specified index.
    pub fn row(&self, row: usize) -> Option<&[T]> {
        let start_idx = self.index(row, 0);
        let end_idx = self.index(row, self.cols());
        // note, this is an inclusive range
        self.data.get(start_idx..end_idx)
    }

    /// Returns the number of rows in the table; a.k.a, the height.
    pub fn rows(&self) -> usize {
        self.height
    }

    /// Returns the number of columns in the table; a.k.a, the width.
    pub fn cols(&self) -> usize {
        self.width
    }

    /// Fills the table with values generated by the provided function.
    ///
    /// # Arguments
    ///
    /// - `value_producer` - A function that takes the row and column indices and returns a value of type `T`.
    pub fn fill<ValueProducer: Fn(usize, usize) -> T>(&mut self, value_producer: ValueProducer) {
        for row in 0..self.rows() {
            for col in 0..self.cols() {
                self.insert(value_producer(row, col), row, col);
            }
        }
    }

    /// Helper to calculate the index with a given row and column.
    fn index(&self, row: usize, col: usize) -> usize {
        row * self.width + col
    }
}

impl<T: Display, const CAP: usize> Display for Table<T, CAP> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut output = "".to_string();

        for row in 0..self.rows() {
            let row_data = self.row(row).unwrap();
            for (col, item) in row_data.iter().enumerate() {
                output.push_str(format!("{item}").as_str());
                if col < self.cols() - 1 {
                    output.push(',');
                    output.push(' ');
                }
            }

            if row < self.rows() - 1 {
                output.push('\n');
            }
        }

        write!(f, "{output}")
    }
}

#[cfg(test)]
mod tests {
    use crate::table::Table;

    #[test]
    fn initialize_and_fill() {
        const SIZE: usize = 8;
        let iota = |row: usize, col: usize| -> usize { row * SIZE + col };

        let mut table = Table::<usize, 64>::new(8, 8);
        table.fill(iota);

        for row in 0..table.rows() {
            for col in 0..table.cols() {
                let val = table.at(row, col);
                assert!(val.is_some());
                assert_eq!(*val.unwrap(), iota(row, col));
            }
        }
    }

    #[test]
    #[should_panic]
    fn expect_panic_with_cap_mismatch() {
        const SIZE: usize = 8;
        let _ = Table::<usize, SIZE>::new(8, 8);
    }

    #[test]
    #[should_panic]
    fn insert_invalid_index() {
        const SIZE: usize = 8;
        let mut table = Table::<usize, SIZE>::new(8, 8);
        table.insert(0, 0, 10);
    }

    #[test]
    fn index_calculation() {
        const SIZE: usize = 64;
        let table = Table::<usize, SIZE>::new(8, 8);
        let mut i = 0;
        for row in 0..table.rows() {
            for col in 0..table.cols() {
                assert_eq!(table.index(row, col), i);
                i += 1;
            }
        }
    }

    #[test]
    fn read_row() {
        const SIZE: usize = 64;
        let mut table = Table::<usize, SIZE>::new(8, 8);
        table.fill(|_, col| col);

        for row in 0..table.rows() {
            let row_data = table.row(row).unwrap();
            assert!(row_data.len() == table.cols());
            for (i, item) in row_data.iter().enumerate() {
                assert_eq!(*item, i);
            }
        }
    }

    #[test]
    fn verify_formatting() {
        const SIZE: usize = 64;
        let mut table = Table::<usize, SIZE>::new(8, 8);
        table.fill(|row, col| row * 8 + col);
        let formatted = format!("{table}");
        println!("{formatted}");
        let expected = "0, 1, 2, 3, 4, 5, 6, 7\n\
                        8, 9, 10, 11, 12, 13, 14, 15\n\
                        16, 17, 18, 19, 20, 21, 22, 23\n\
                        24, 25, 26, 27, 28, 29, 30, 31\n\
                        32, 33, 34, 35, 36, 37, 38, 39\n\
                        40, 41, 42, 43, 44, 45, 46, 47\n\
                        48, 49, 50, 51, 52, 53, 54, 55\n\
                        56, 57, 58, 59, 60, 61, 62, 63";

        assert_eq!(formatted, expected);
    }
}
