use std::fmt::Display;

use arrayvec::ArrayVec;

/// A generic 2D table for general use in chess engines.
#[derive(Debug, Clone)]
pub(crate) struct Table<T, const CAP: usize> {
    data: ArrayVec<T, CAP>,
    width: usize,
    height: usize,
}

impl<T, const CAP: usize> Table<T, CAP> {
    /// Creates a new table with the specified width and height.
    /// The table is initialized with a capacity of `CAP` elements.
    /// The width and height are the number of columns and rows respectively.
    ///
    /// # Arguments
    ///
    /// - `width` - The number of columns in the table.
    /// - `height` - The number of rows in the table.
    ///
    /// # Returns
    ///
    /// A new instance of `Table<T, CAP>`.
    ///
    /// # Panics
    ///
    /// This function will panic if width*height > CAP.
    pub fn new(width: usize, height: usize) -> Self {
        assert!(
            width * height <= CAP,
            "Table capacity exceeded: {} > {}",
            width * height,
            CAP
        );
        assert!(
            width > 0 && height > 0,
            "Width and height must be greater than zero"
        );
        Self {
            data: ArrayVec::<T, CAP>::new(),
            width,
            height,
        }
    }

    /// Insert an element at the given row and column.
    ///
    /// # Arguments
    ///
    /// - `value` - The value to insert.
    /// - `row` - The row index.
    /// - `col` - The column index.
    pub fn insert(&mut self, value: T, row: usize, col: usize) {
        assert!(
            row < self.rows() && col < self.cols(),
            "Invalid row or column index"
        );
        self.data.insert(self.index(row, col), value);
    }

    /// Get a mutable reference to the element at the given row and column, if it exists.
    ///
    /// # Arguments
    ///
    /// - `row` - The row index.
    /// - `col` - The column index.
    ///
    /// # Returns
    ///
    /// An `Option<&T>` that contains a reference to the element at the specified row and column, or `None` if it does not exist.
    pub fn at(&self, row: usize, col: usize) -> Option<&T> {
        self.data.get(self.index(row, col))
    }

    /// Get a slice of the given row.
    ///
    /// # Arguments
    ///
    /// - `row` - The row index.
    ///
    /// # Returns
    ///
    /// A slice of the row at the specified index.
    pub fn row(&self, row: usize) -> &[T] {
        let start_idx = self.index(row, 0);
        let end_idx = self.index(row, self.cols() - 1);
        // note, this is an inclusive range
        self.data.get(start_idx..end_idx).expect("Invalid range")
    }

    /// Returns the number of rows in the table; a.k.a, the height.
    pub fn rows(&self) -> usize {
        self.height
    }

    /// Returns the number of columns in the table; a.k.a, the width.
    pub fn cols(&self) -> usize {
        self.width
    }

    /// Fills the table with values generated by the provided function.
    ///
    /// # Arguments
    ///
    /// - `value_producer` - A function that takes the row and column indices and returns a value of type `T`.
    pub fn fill<ValueProducer: Fn(usize, usize) -> T>(&mut self, value_producer: ValueProducer) {
        for row in 0..self.rows() {
            for col in 0..self.cols() {
                self.insert(value_producer(row, col), row, col);
            }
        }
    }

    /// Helper to calculate the index with a given row and column.
    fn index(&self, row: usize, col: usize) -> usize {
        row * self.width + col
    }
}

impl<T: Display, const CAP: usize> Display for Table<T, CAP> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut output = "".to_string();

        for row in 0..self.rows() {
            let row_data = self.row(row);
            for (col, item) in row_data.iter().enumerate() {
                output.push_str(format!("{}", item).as_str());
                if col < self.cols() {
                    output.push(',');
                    output.push(' ');
                }
            }

            output.push('\n');
        }

        write!(f, "{}", output)
    }
}

#[cfg(test)]
mod tests {
    use crate::table::Table;

    #[test]
    fn initialize_and_fill() {
        const SIZE: usize = 8;
        let iota = |row: usize, col: usize| -> usize { row * SIZE + col };

        let mut table = Table::<usize, 64>::new(8, 8);
        table.fill(iota);

        for row in 0..table.rows() {
            for col in 0..table.cols() {
                let val = table.at(row, col);
                assert!(val.is_some());
                assert_eq!(*val.unwrap(), iota(row, col));
            }
        }
    }

    #[test]
    #[should_panic]
    fn expect_panic_with_cap_mismatch() {
        const SIZE: usize = 8;
        let _ = Table::<usize, SIZE>::new(8, 8);
    }

    #[test]
    fn index_calculation() {
        const SIZE: usize = 64;
        let table = Table::<usize, SIZE>::new(8, 8);
        let mut i = 0;
        for row in 0..table.rows() {
            for col in 0..table.cols() {
                assert_eq!(table.index(row, col), i);
                i += 1;
            }
        }
    }
}
