/*
 * Part of the byte-knight project
 * Author: Paul Tsouchlos (DeveloperPaul123) (developer.paul.123@gmail.com)
 * Copyright (c) 2024 Paul Tsouchlos (DeveloperPaul123)
 * GNU General Public License v3.0 or later
 * https://www.gnu.org/licenses/gpl-3.0-standalone.html
 */

use chess::{
    definitions::NumberOf,
    pieces::Piece,
    side::Side,
    square::{self},
};

use crate::{
    phased_score::{PhasedScore, S},
    score::ScoreType,
    traits::EvalValues,
};

/// Game phase increment for each piece
/// Ordered to match the indexing of [`Piece`]
/// King, Queen, Rook, Bishop, Knight, Pawn
pub const GAME_PHASE_INC: [ScoreType; 6] = [0, 4, 2, 1, 1, 0];

/// Maximum game phase
pub const GAME_PHASE_MAX: i32 = 24;

/// Piece-Square Tables, ordered by the ordinality of the pieces. See ['pieces::Piece']
#[rustfmt::skip]
pub const PSQTS : [[PhasedScore; NumberOf::SQUARES]; NumberOf::PIECE_TYPES] = [
    // King
    [
        S(  21,  -97), S(   1,  -42), S(  16,  -23), S(-118,   26), S( -76,   10), S(  -4,    5), S(  59,   -6), S( 182, -122),
        S(-111,    6), S( -71,   38), S(-111,   51), S(  -6,   35), S( -54,   54), S( -46,   65), S(   3,   51), S( -15,   16),
        S(-131,   20), S( -17,   41), S( -90,   62), S(-109,   73), S( -67,   73), S(  17,   64), S(  -2,   60), S( -46,   29),
        S( -95,    9), S(-105,   46), S(-125,   67), S(-174,   81), S(-160,   81), S(-120,   75), S(-115,   62), S(-139,   33),
        S(-100,   -0), S(-101,   32), S(-138,   59), S(-167,   76), S(-164,   74), S(-123,   60), S(-128,   46), S(-157,   29),
        S( -45,  -12), S( -30,   14), S( -93,   39), S(-106,   52), S(-100,   52), S( -97,   43), S( -49,   21), S( -66,    7),
        S(  48,  -32), S(   4,   -2), S( -13,   11), S( -49,   22), S( -51,   26), S( -31,   16), S(  19,   -4), S(  30,  -24),
        S(  45,  -72), S(  66,  -50), S(  38,  -29), S( -67,  -10), S(   0,  -37), S( -41,  -11), S(  46,  -40), S(  49,  -70),
    ],
    // Queen
    [
        S( 778, 1326), S( 790, 1338), S( 818, 1357), S( 855, 1345), S( 852, 1343), S( 866, 1329), S( 883, 1285), S( 821, 1323),
        S( 819, 1291), S( 793, 1335), S( 801, 1371), S( 792, 1393), S( 800, 1408), S( 839, 1362), S( 815, 1352), S( 865, 1323),
        S( 820, 1298), S( 817, 1319), S( 815, 1360), S( 833, 1362), S( 838, 1379), S( 882, 1358), S( 884, 1319), S( 881, 1307),
        S( 802, 1312), S( 807, 1335), S( 813, 1348), S( 810, 1377), S( 813, 1390), S( 825, 1374), S( 825, 1361), S( 831, 1338),
        S( 805, 1306), S( 802, 1337), S( 802, 1348), S( 809, 1369), S( 808, 1369), S( 808, 1359), S( 820, 1336), S( 823, 1326),
        S( 803, 1291), S( 811, 1311), S( 805, 1337), S( 804, 1336), S( 807, 1340), S( 814, 1329), S( 828, 1305), S( 820, 1292),
        S( 800, 1288), S( 806, 1292), S( 817, 1289), S( 816, 1301), S( 815, 1304), S( 824, 1274), S( 830, 1242), S( 841, 1212),
        S( 798, 1282), S( 788, 1289), S( 795, 1292), S( 811, 1282), S( 803, 1287), S( 789, 1284), S( 812, 1254), S( 804, 1257),
    ],
    // Rook
    [
        S( 439,  707), S( 430,  714), S( 438,  722), S( 441,  719), S( 461,  709), S( 476,  699), S( 452,  705), S( 480,  696),
        S( 420,  706), S( 418,  719), S( 438,  722), S( 459,  714), S( 445,  713), S( 476,  696), S( 462,  694), S( 494,  681),
        S( 400,  705), S( 421,  707), S( 424,  708), S( 427,  706), S( 457,  692), S( 462,  684), S( 500,  676), S( 475,  673),
        S( 382,  708), S( 395,  706), S( 400,  714), S( 409,  710), S( 414,  695), S( 416,  688), S( 426,  686), S( 427,  678),
        S( 362,  702), S( 365,  706), S( 377,  707), S( 389,  705), S( 389,  701), S( 374,  699), S( 400,  686), S( 389,  682),
        S( 355,  696), S( 365,  695), S( 375,  694), S( 374,  699), S( 380,  694), S( 377,  687), S( 413,  665), S( 390,  667),
        S( 351,  690), S( 364,  694), S( 381,  693), S( 377,  695), S( 382,  686), S( 384,  682), S( 402,  672), S( 369,  680),
        S( 371,  683), S( 374,  694), S( 384,  702), S( 389,  700), S( 394,  692), S( 383,  687), S( 400,  684), S( 374,  674),
    ],
    // Bishop
    [
        S( 294,  388), S( 275,  403), S( 286,  397), S( 245,  411), S( 257,  404), S( 272,  395), S( 306,  393), S( 263,  387),
        S( 312,  378), S( 335,  396), S( 330,  401), S( 314,  404), S( 344,  392), S( 342,  394), S( 331,  399), S( 323,  374),
        S( 326,  404), S( 349,  399), S( 350,  410), S( 374,  399), S( 360,  404), S( 392,  407), S( 368,  399), S( 356,  399),
        S( 315,  401), S( 332,  416), S( 352,  412), S( 365,  426), S( 360,  419), S( 356,  415), S( 331,  414), S( 317,  401),
        S( 310,  399), S( 322,  414), S( 331,  423), S( 350,  422), S( 348,  420), S( 331,  418), S( 323,  411), S( 318,  386),
        S( 320,  396), S( 329,  408), S( 327,  417), S( 332,  417), S( 332,  422), S( 327,  415), S( 330,  397), S( 333,  387),
        S( 324,  392), S( 324,  390), S( 337,  389), S( 313,  404), S( 322,  406), S( 333,  394), S( 341,  396), S( 327,  371),
        S( 299,  371), S( 323,  391), S( 304,  371), S( 296,  394), S( 300,  388), S( 299,  390), S( 323,  376), S( 312,  356),
    ],
    // Knight
    [
        S( 131,  289), S( 171,  354), S( 234,  374), S( 267,  363), S( 303,  367), S( 240,  345), S( 188,  356), S( 187,  267),
        S( 272,  352), S( 290,  373), S( 317,  379), S( 340,  378), S( 320,  373), S( 383,  355), S( 288,  369), S( 314,  335),
        S( 291,  365), S( 327,  381), S( 344,  400), S( 357,  401), S( 395,  384), S( 401,  375), S( 352,  373), S( 320,  355),
        S( 287,  379), S( 301,  400), S( 328,  412), S( 349,  414), S( 331,  415), S( 356,  409), S( 312,  400), S( 323,  369),
        S( 273,  379), S( 289,  391), S( 305,  414), S( 306,  415), S( 315,  418), S( 310,  406), S( 309,  391), S( 284,  371),
        S( 253,  363), S( 277,  384), S( 291,  393), S( 295,  408), S( 307,  406), S( 296,  389), S( 300,  377), S( 270,  364),
        S( 240,  355), S( 251,  371), S( 270,  381), S( 282,  382), S( 283,  381), S( 285,  377), S( 272,  361), S( 268,  365),
        S( 196,  346), S( 250,  330), S( 237,  364), S( 252,  365), S( 257,  366), S( 270,  355), S( 252,  337), S( 225,  342),
    ],
    // Pawn
    [
        S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0),
        S( 172,  309), S( 187,  312), S( 171,  307), S( 205,  254), S( 180,  254), S( 163,  262), S(  93,  316), S(  79,  314),
        S(  76,  150), S(  85,  166), S( 119,  115), S( 119,   79), S( 129,   75), S( 163,   91), S( 133,  144), S(  99,  131),
        S(  53,  133), S(  71,  137), S(  80,  113), S(  81,   95), S( 104,   96), S(  99,   98), S(  93,  128), S(  81,  108),
        S(  42,  115), S(  62,  126), S(  67,  107), S(  84,  101), S(  83,  102), S(  77,  103), S(  76,  120), S(  66,   97),
        S(  40,  110), S(  58,  123), S(  64,  107), S(  63,  111), S(  78,  112), S(  71,  107), S(  93,  115), S(  72,   93),
        S(  40,  114), S(  57,  125), S(  59,  114), S(  47,  110), S(  67,  122), S(  85,  109), S( 100,  113), S(  64,   94),
        S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0),
    ],
];

pub const PASSED_PAWN_BONUS: [PhasedScore; NumberOf::PASSED_PAWN_RANKS] = [
    S(-24, 7),
    S(7, 126),
    S(13, 60),
    S(-9, 36),
    S(-12, 13),
    S(-6, 8),
];

pub const DOUBLED_PAWN_VALUES: [PhasedScore; NumberOf::FILES] = [
    S(-14, -29),
    S(6, -25),
    S(-5, -15),
    S(-1, -6),
    S(-11, -3),
    S(-8, -17),
    S(-3, -29),
    S(-12, -40),
];

pub const ISOLATED_PAWN_VALUES: [PhasedScore; NumberOf::FILES] = [
    S(-3, -0),
    S(-10, -17),
    S(-20, -13),
    S(-19, -23),
    S(-20, -24),
    S(-14, -10),
    S(-14, -16),
    S(-12, 5),
];

const RANK_1: u8 = 1;

#[derive(Debug, Clone, Copy, Default)]
pub struct ByteKnightValues {}

impl EvalValues for ByteKnightValues {
    type ReturnScore = PhasedScore;

    fn psqt(&self, square: u8, piece: Piece, side: Side) -> Self::ReturnScore {
        PSQTS[piece as usize][square::flip_if(side == Side::White, square) as usize]
    }

    fn passed_pawn_bonus(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (_file, rank) = square::from_square(square::flip_if(side == Side::White, square));
        PASSED_PAWN_BONUS[(rank - RANK_1) as usize]
    }

    fn doubled_pawn_value(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (file, _rank) = square::from_square(square::flip_if(side == Side::White, square));
        DOUBLED_PAWN_VALUES[file as usize]
    }

    fn isolated_pawn_value(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (file, _rank) = square::from_square(square::flip_if(side == Side::White, square));
        ISOLATED_PAWN_VALUES[file as usize]
    }
}
