use chess::{
    definitions::NumberOf,
    pieces::Piece,
    side::Side,
    square::{self},
};

use crate::{
    phased_score::{PhasedScore, S},
    score::ScoreType,
    traits::EvalValues,
};

/// Game phase increment for each piece
/// Ordered to match the indexing of [`Piece`]
/// King, Queen, Rook, Bishop, Knight, Pawn
pub const GAME_PHASE_INC: [ScoreType; 6] = [0, 4, 2, 1, 1, 0];

/// Maximum game phase
pub const GAME_PHASE_MAX: i32 = 24;

/// Piece-Square Tables, ordered by the ordinality of the pieces. See ['pieces::Piece']
#[rustfmt::skip]
pub const PSQTS : [[PhasedScore; NumberOf::SQUARES]; NumberOf::PIECE_TYPES] = [
    // King
    [
        S(  16,  -99), S(  -0,  -44), S(  18,  -26), S(-122,   25), S( -77,    7), S( -10,    6), S(  60,   -7), S( 181, -125),
        S(-113,    4), S( -73,   38), S(-109,   50), S(  -8,   34), S( -56,   53), S( -50,   65), S(   5,   51), S( -14,   17),
        S(-134,   20), S( -16,   41), S( -90,   62), S(-115,   74), S( -70,   72), S(  17,   64), S(  -4,   61), S( -46,   30),
        S( -95,   10), S(-108,   47), S(-124,   68), S(-176,   81), S(-163,   81), S(-122,   75), S(-116,   63), S(-142,   35),
        S( -99,    0), S(-102,   33), S(-140,   60), S(-171,   78), S(-165,   75), S(-124,   61), S(-129,   47), S(-157,   30),
        S( -45,  -12), S( -29,   15), S( -91,   40), S(-105,   53), S( -99,   53), S( -96,   43), S( -47,   21), S( -65,    7),
        S(  51,  -32), S(   5,   -2), S( -10,   11), S( -47,   22), S( -49,   26), S( -29,   16), S(  22,   -4), S(  33,  -24),
        S(  46,  -73), S(  70,  -50), S(  41,  -29), S( -66,  -10), S(   3,  -37), S( -40,  -11), S(  50,  -41), S(  52,  -71),
    ],
    // Queen
    [
        S( 790, 1351), S( 802, 1361), S( 832, 1381), S( 866, 1369), S( 865, 1367), S( 877, 1353), S( 896, 1307), S( 835, 1344),
        S( 832, 1313), S( 807, 1357), S( 814, 1393), S( 806, 1415), S( 812, 1432), S( 853, 1386), S( 828, 1374), S( 879, 1346),
        S( 834, 1321), S( 831, 1340), S( 828, 1383), S( 844, 1386), S( 850, 1402), S( 896, 1381), S( 898, 1342), S( 894, 1330),
        S( 814, 1335), S( 819, 1358), S( 825, 1371), S( 822, 1399), S( 825, 1413), S( 838, 1398), S( 838, 1384), S( 844, 1361),
        S( 817, 1329), S( 814, 1361), S( 815, 1369), S( 822, 1391), S( 821, 1391), S( 820, 1381), S( 832, 1358), S( 836, 1347),
        S( 814, 1315), S( 823, 1333), S( 817, 1360), S( 816, 1359), S( 819, 1363), S( 827, 1352), S( 840, 1327), S( 833, 1314),
        S( 812, 1312), S( 818, 1315), S( 830, 1312), S( 829, 1322), S( 827, 1326), S( 837, 1297), S( 843, 1263), S( 854, 1234),
        S( 810, 1305), S( 799, 1312), S( 807, 1315), S( 823, 1304), S( 814, 1309), S( 800, 1308), S( 824, 1275), S( 816, 1279),
    ],
    // Rook
    [
        S( 447,  718), S( 437,  726), S( 445,  735), S( 449,  731), S( 469,  721), S( 486,  710), S( 465,  715), S( 491,  707),
        S( 428,  718), S( 425,  731), S( 446,  734), S( 468,  725), S( 452,  725), S( 484,  709), S( 471,  704), S( 504,  692),
        S( 405,  718), S( 428,  719), S( 430,  720), S( 433,  718), S( 463,  703), S( 470,  696), S( 509,  687), S( 483,  684),
        S( 388,  720), S( 402,  718), S( 406,  726), S( 414,  722), S( 421,  706), S( 425,  699), S( 434,  698), S( 434,  690),
        S( 367,  714), S( 371,  718), S( 382,  719), S( 394,  717), S( 394,  712), S( 381,  711), S( 406,  697), S( 394,  694),
        S( 360,  708), S( 371,  707), S( 381,  706), S( 379,  711), S( 386,  705), S( 383,  698), S( 420,  676), S( 396,  678),
        S( 357,  701), S( 370,  706), S( 387,  705), S( 383,  706), S( 388,  697), S( 390,  694), S( 409,  683), S( 375,  691),
        S( 377,  695), S( 380,  705), S( 390,  714), S( 395,  711), S( 400,  704), S( 389,  698), S( 406,  695), S( 380,  685),
    ],
    // Bishop
    [
        S( 301,  393), S( 280,  410), S( 291,  404), S( 249,  418), S( 262,  410), S( 278,  402), S( 313,  398), S( 269,  392),
        S( 317,  384), S( 343,  402), S( 337,  407), S( 320,  409), S( 350,  399), S( 349,  399), S( 339,  405), S( 330,  379),
        S( 331,  411), S( 355,  406), S( 356,  416), S( 379,  406), S( 365,  411), S( 399,  413), S( 374,  405), S( 362,  406),
        S( 321,  407), S( 337,  424), S( 359,  418), S( 370,  432), S( 366,  425), S( 363,  422), S( 337,  422), S( 322,  407),
        S( 315,  405), S( 328,  422), S( 336,  430), S( 356,  428), S( 353,  426), S( 337,  425), S( 329,  419), S( 323,  392),
        S( 325,  403), S( 334,  414), S( 333,  424), S( 338,  424), S( 337,  428), S( 333,  421), S( 335,  404), S( 338,  392),
        S( 329,  397), S( 329,  397), S( 343,  395), S( 318,  411), S( 327,  412), S( 339,  400), S( 346,  401), S( 332,  376),
        S( 305,  376), S( 328,  397), S( 309,  377), S( 301,  400), S( 305,  395), S( 304,  395), S( 329,  382), S( 317,  361),
    ],
    // Knight
    [
        S( 134,  295), S( 175,  359), S( 238,  380), S( 272,  369), S( 308,  373), S( 246,  350), S( 194,  362), S( 191,  272),
        S( 277,  358), S( 296,  379), S( 324,  386), S( 345,  384), S( 326,  378), S( 392,  361), S( 295,  374), S( 322,  340),
        S( 296,  371), S( 333,  388), S( 350,  406), S( 362,  408), S( 402,  390), S( 406,  383), S( 357,  379), S( 325,  361),
        S( 291,  386), S( 306,  407), S( 333,  419), S( 354,  421), S( 336,  421), S( 363,  416), S( 317,  406), S( 328,  376),
        S( 277,  386), S( 293,  397), S( 309,  421), S( 310,  422), S( 320,  426), S( 315,  413), S( 314,  398), S( 289,  376),
        S( 257,  368), S( 281,  389), S( 296,  400), S( 300,  415), S( 312,  413), S( 301,  395), S( 304,  382), S( 274,  370),
        S( 243,  361), S( 255,  377), S( 273,  387), S( 286,  389), S( 287,  387), S( 290,  384), S( 275,  366), S( 272,  371),
        S( 197,  352), S( 254,  335), S( 240,  370), S( 256,  372), S( 261,  372), S( 274,  361), S( 256,  342), S( 228,  345),
    ],
    // Pawn
    [
        S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0),
        S( 169,  318), S( 191,  308), S( 171,  306), S( 201,  247), S( 179,  247), S( 168,  264), S( 104,  310), S(  70,  325),
        S(  81,  165), S(  95,  170), S( 127,  122), S( 126,   82), S( 136,   78), S( 172,  104), S( 148,  146), S( 100,  148),
        S(  59,  148), S(  81,  143), S(  87,  121), S(  88,  100), S( 112,  100), S( 106,  112), S( 109,  131), S(  82,  125),
        S(  47,  131), S(  72,  134), S(  74,  116), S(  90,  106), S(  89,  107), S(  84,  116), S(  92,  124), S(  67,  113),
        S(  45,  125), S(  68,  132), S(  71,  116), S(  70,  118), S(  86,  118), S(  78,  120), S( 109,  121), S(  73,  109),
        S(  45,  129), S(  68,  134), S(  65,  123), S(  53,  117), S(  75,  128), S(  92,  123), S( 117,  119), S(  65,  109),
        S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0),
    ],
];

pub const PASSED_PAWN_BONUS: [PhasedScore; NumberOf::PASSED_PAWN_RANKS] = [
    S(-19, 7),
    S(4, 119),
    S(8, 52),
    S(-16, 25),
    S(-21, 1),
    S(-14, -2),
];

pub const DOUBLED_PAWN_VALUES: [PhasedScore; NumberOf::FILES] = [
    S(-21, -46),
    S(-3, -38),
    S(-16, -35),
    S(-11, -23),
    S(-19, -22),
    S(-17, -35),
    S(-20, -34),
    S(-24, -51),
];

pub const ISOLATED_PAWN_VALUES: [PhasedScore; NumberOf::FILES] = [
    S(-1, -2),
    S(-1, -2),
    S(-1, -2),
    S(-1, -2),
    S(-1, -2),
    S(-1, -2),
    S(-1, -2),
    S(-1, -2),
];

const RANK_1: u8 = 1;

#[derive(Debug, Clone, Copy, Default)]
pub struct ByteKnightValues {}

impl EvalValues for ByteKnightValues {
    type ReturnScore = PhasedScore;

    fn psqt(&self, square: u8, piece: Piece, side: Side) -> Self::ReturnScore {
        PSQTS[piece as usize][square::flip_if(side == Side::White, square) as usize]
    }

    fn passed_pawn_bonus(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (_file, rank) = square::from_square(square::flip_if(side == Side::White, square));
        PASSED_PAWN_BONUS[(rank - RANK_1) as usize]
    }

    fn doubled_pawn_value(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (file, _rank) = square::from_square(square::flip_if(side == Side::White, square));
        DOUBLED_PAWN_VALUES[file as usize]
    }

    fn isolated_pawn_value(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (file, _rank) = square::from_square(square::flip_if(side == Side::White, square));
        ISOLATED_PAWN_VALUES[file as usize]
    }
}
