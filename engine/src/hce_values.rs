use chess::{
    definitions::NumberOf,
    pieces::Piece,
    side::Side,
    square::{self},
};

use crate::{
    phased_score::{PhasedScore, S},
    traits::EvalValues,
};

/// Piece-Square Tables, ordered by the ordinality of the pieces. See ['pieces::Piece']
#[rustfmt::skip]
pub const PSQTS : [[PhasedScore; NumberOf::SQUARES]; NumberOf::PIECE_TYPES] = [
    // King
    [
        S( -33,   -2), S( -18,    2), S(  -2,    2), S(   4,   -2), S(  13,   -2), S(   8,   -2), S(  -1,    2), S(  -6,   -2), 
        S(  -6,    2), S(   7,    1), S(  19,    2), S(  21,   -2), S(  26,   -2), S(  27,    2), S(  17,    2), S(   9,    2), 
        S(  10,   -2), S(  35,    2), S(  34,    2), S(  49,    2), S(  40,    2), S(  38,    2), S(  38,    2), S(  26,   -2), 
        S(  -1,   -2), S(  18,    2), S(  39,    2), S(  57,    2), S(  56,    2), S(  51,    2), S(  54,    2), S(  24,   -2), 
        S(  12,   -2), S(  21,    2), S(  47,    2), S(  47,    2), S(  51,    2), S(  48,    2), S(  45,    2), S(  25,   -2), 
        S(   4,   -2), S(  28,    1), S(  36,    2), S(  47,    2), S(  38,    2), S(  40,    2), S(  27,   -2), S(  19,   -2), 
        S(   0,   -2), S(  19,   -2), S(  22,   -2), S(  21,   -2), S(  27,   -2), S(  22,   -2), S(  15,   -2), S(   7,   -2), 
        S(  -7,   -2), S( -33,   -2), S( -10,   -2), S(   8,   -2), S(   1,   -2), S(   3,   -2), S( -14,   -2), S(  -8,   -2), 
    ],
    // Queen
    [
        S( 901,  902), S( 899,  898), S( 899,  898), S( 902,  902), S( 899,  898), S( 899,  898), S( 899,  898), S( 900,  902), 
        S( 899,  898), S( 899,  898), S( 902,  902), S( 902,  902), S( 902,  902), S( 902,  902), S( 899,  898), S( 901,  902), 
        S( 899,  898), S( 902,  902), S( 902,  902), S( 902,  902), S( 902,  902), S( 902,  902), S( 902,  902), S( 902,  902), 
        S( 901,  902), S( 899,  902), S( 901,  902), S( 902,  902), S( 902,  902), S( 902,  902), S( 902,  902), S( 902,  902), 
        S( 898,  898), S( 899,  898), S( 899,  898), S( 902,  902), S( 902,  902), S( 901,  902), S( 902,  902), S( 902,  902), 
        S( 899,  898), S( 898,  898), S( 899,  898), S( 898,  898), S( 898,  898), S( 899,  902), S( 901,  902), S( 902,  902), 
        S( 898,  898), S( 898,  898), S( 898,  898), S( 898,  898), S( 898,  898), S( 898,  898), S( 898,  898), S( 901,  902), 
        S( 899,  898), S( 898,  898), S( 898,  898), S( 898,  898), S( 898,  898), S( 898,  898), S( 899,  898), S( 900,  898), 
    ],
    // Rook
    [
        S( 502,  502), S( 502,  502), S( 502,  502), S( 502,  502), S( 502,  502), S( 502,  502), S( 501,  502), S( 502,  502), 
        S( 499,  498), S( 501,  502), S( 502,  502), S( 502,  502), S( 501,  502), S( 501,  501), S( 501,  502), S( 499,  498), 
        S( 500,  498), S( 501,  502), S( 501,  502), S( 501,  502), S( 501,  502), S( 501,  502), S( 502,  502), S( 501,  502), 
        S( 501,  502), S( 501,  500), S( 501,  502), S( 502,  502), S( 501,  502), S( 501,  499), S( 500,  498), S( 501,  498), 
        S( 500,  499), S( 500,  498), S( 501,  502), S( 501,  502), S( 501,  502), S( 499,  498), S( 501,  498), S( 501,  498), 
        S( 499,  498), S( 499,  499), S( 499,  502), S( 501,  502), S( 499,  498), S( 498,  498), S( 501,  501), S( 499,  498), 
        S( 498,  498), S( 499,  502), S( 499,  502), S( 498,  498), S( 498,  498), S( 498,  498), S( 499,  498), S( 499,  498), 
        S( 498,  498), S( 498,  498), S( 498,  498), S( 498,  498), S( 498,  498), S( 498,  498), S( 498,  498), S( 498,  498), 
    ],
    // Bishop
    [
        S( 223,  298), S( 252,  302), S( 272,  302), S( 275,  298), S( 264,  298), S( 250,  302), S( 236,  298), S( 264,  298), 
        S( 260,  301), S( 264,  302), S( 262,  302), S( 270,  302), S( 262,  302), S( 261,  302), S( 247,  302), S( 242,  302), 
        S( 266,  302), S( 270,  302), S( 278,  302), S( 267,  302), S( 280,  302), S( 267,  302), S( 276,  302), S( 254,  302), 
        S( 261,  299), S( 267,  302), S( 274,  302), S( 282,  302), S( 269,  302), S( 274,  302), S( 267,  302), S( 266,  302), 
        S( 281,  298), S( 278,  302), S( 296,  302), S( 276,  302), S( 279,  302), S( 280,  302), S( 293,  302), S( 257,  298), 
        S( 272,  298), S( 282,  302), S( 288,  302), S( 295,  302), S( 264,  302), S( 278,  302), S( 256,  302), S( 272,  302), 
        S( 270,  298), S( 276,  298), S( 286,  298), S( 265,  298), S( 263,  298), S( 239,  298), S( 273,  298), S( 247,  298), 
        S( 240,  298), S( 224,  298), S( 262,  298), S( 289,  298), S( 257,  298), S( 259,  298), S( 205,  298), S( 245,  298), 
    ],
    // Knight
    [
        S( 164,  298), S( 214,  298), S( 220,  298), S( 234,  298), S( 192,  298), S( 226,  298), S( 184,  298), S( 146,  298), 
        S( 228,  298), S( 254,  298), S( 220,  298), S( 256,  302), S( 247,  298), S( 204,  298), S( 207,  298), S( 187,  298), 
        S( 221,  298), S( 227,  298), S( 238,  302), S( 241,  302), S( 248,  302), S( 238,  302), S( 223,  302), S( 219,  298), 
        S( 250,  298), S( 254,  298), S( 263,  302), S( 257,  302), S( 253,  302), S( 238,  302), S( 233,  298), S( 213,  302), 
        S( 250,  298), S( 243,  302), S( 248,  302), S( 256,  302), S( 244,  302), S( 240,  302), S( 223,  302), S( 222,  298), 
        S( 226,  298), S( 244,  298), S( 257,  298), S( 249,  302), S( 256,  302), S( 256,  298), S( 236,  298), S( 220,  298), 
        S( 216,  298), S( 221,  298), S( 228,  298), S( 260,  298), S( 233,  298), S( 210,  298), S( 230,  298), S( 230,  298), 
        S( 196,  298), S( 222,  298), S( 215,  298), S( 225,  298), S( 229,  298), S( 201,  298), S( 197,  298), S( 142,  298), 
    ],
    // Pawn
    [
        S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), 
        S( 130,  102), S( 106,  102), S(  88,  102), S( 128,   98), S( 104,  102), S(  90,  102), S( 109,  102), S( 112,  102), 
        S( 130,  102), S( 113,  102), S(  89,  102), S(  94,   98), S(  93,  102), S(  94,   98), S( 111,  102), S( 113,  102), 
        S( 131,  102), S( 113,  102), S(  88,  102), S(  83,  102), S(  87,  102), S(  96,  102), S( 105,  101), S( 116,  102), 
        S( 132,   98), S( 111,   98), S(  86,   98), S(  79,   98), S(  82,  102), S(  92,   98), S( 105,   98), S( 116,   98), 
        S( 133,   98), S( 117,   98), S(  95,   98), S(  90,   98), S(  88,   98), S(  96,   98), S( 108,   98), S( 114,   98), 
        S( 127,   98), S( 117,   98), S(  90,   98), S( 130,   98), S( 108,   98), S(  90,   98), S( 102,   98), S( 117,   98), 
        S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), S( 100,  100), 
    ],
];

#[derive(Debug, Clone, Copy, Default)]
pub struct ByteKnightValues {}

impl EvalValues for ByteKnightValues {
    type ReturnScore = PhasedScore;

    fn psqt(&self, square: u8, piece: Piece, side: Side) -> Self::ReturnScore {
        PSQTS[piece as usize][square::flip_if(side == Side::White, square) as usize]
    }
}

#[cfg(test)]
mod tests {
    use chess::board::Board;

    use super::*;
    use crate::{evaluation::Evaluation, psqt::Psqt, traits::Eval};

    #[test]
    fn verify_values_match_pesto() {
        let values = ByteKnightValues::default();
        let eval = Evaluation::new(values);

        let psqt = Psqt::new();

        let board =
            Board::from_fen("r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1")
                .unwrap();

        let score = psqt.evaluate(&board);
        println!("{}", score);
        let new_eval_score = eval.eval(&board);
        println!("{}", new_eval_score);
        assert_eq!(score, new_eval_score);
    }
}
