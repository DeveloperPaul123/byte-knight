use chess::{
    definitions::NumberOf,
    pieces::Piece,
    side::Side,
    square::{self},
};

use crate::{
    phased_score::{PhasedScore, S},
    score::ScoreType,
    traits::EvalValues,
};

/// Game phase increment for each piece
/// Ordered to match the indexing of [`Piece`]
/// King, Queen, Rook, Bishop, Knight, Pawn
pub const GAME_PHASE_INC: [ScoreType; 6] = [0, 4, 2, 1, 1, 0];

/// Maximum game phase
pub const GAME_PHASE_MAX: i32 = 24;

/// Piece-Square Tables, ordered by the ordinality of the pieces. See ['pieces::Piece']
#[rustfmt::skip]
pub const PSQTS : [[PhasedScore; NumberOf::SQUARES]; NumberOf::PIECE_TYPES] = [
    // King
    [
        S(  20,  -98), S(   1,  -42), S(  16,  -24), S(-119,   26), S( -76,    9), S(  -5,    5), S(  60,   -6), S( 182, -123),
        S(-111,    6), S( -71,   38), S(-111,   52), S(  -6,   35), S( -54,   54), S( -46,   66), S(   3,   51), S( -14,   16),
        S(-132,   20), S( -16,   41), S( -90,   62), S(-110,   74), S( -67,   74), S(  17,   65), S(  -1,   61), S( -46,   29),
        S( -96,    9), S(-105,   46), S(-125,   68), S(-175,   82), S(-161,   82), S(-121,   75), S(-115,   62), S(-139,   33),
        S(-101,   -0), S(-102,   32), S(-139,   60), S(-168,   77), S(-165,   75), S(-124,   61), S(-129,   46), S(-158,   29),
        S( -45,  -13), S( -30,   14), S( -93,   39), S(-106,   52), S(-100,   53), S( -97,   43), S( -49,   21), S( -66,    7),
        S(  50,  -33), S(   5,   -3), S( -12,   10), S( -49,   22), S( -51,   26), S( -31,   16), S(  20,   -4), S(  31,  -24),
        S(  46,  -73), S(  67,  -51), S(  39,  -30), S( -67,  -10), S(   1,  -37), S( -41,  -11), S(  47,  -41), S(  50,  -71),
    ],
    // Queen
    [
        S( 788, 1341), S( 799, 1353), S( 828, 1372), S( 865, 1359), S( 862, 1357), S( 876, 1343), S( 893, 1299), S( 830, 1337),
        S( 829, 1304), S( 803, 1350), S( 811, 1385), S( 801, 1408), S( 809, 1423), S( 849, 1377), S( 824, 1366), S( 875, 1337),
        S( 830, 1312), S( 827, 1333), S( 825, 1375), S( 842, 1377), S( 848, 1394), S( 892, 1372), S( 895, 1333), S( 891, 1321),
        S( 812, 1326), S( 817, 1349), S( 822, 1363), S( 820, 1391), S( 822, 1405), S( 835, 1389), S( 835, 1376), S( 841, 1352),
        S( 815, 1320), S( 812, 1351), S( 811, 1362), S( 819, 1384), S( 818, 1383), S( 818, 1373), S( 830, 1350), S( 832, 1340),
        S( 812, 1304), S( 820, 1325), S( 814, 1352), S( 813, 1350), S( 816, 1355), S( 824, 1343), S( 838, 1318), S( 830, 1306),
        S( 810, 1302), S( 816, 1306), S( 827, 1303), S( 826, 1315), S( 824, 1317), S( 834, 1288), S( 840, 1255), S( 851, 1225),
        S( 807, 1295), S( 797, 1303), S( 805, 1306), S( 821, 1296), S( 812, 1301), S( 798, 1298), S( 821, 1268), S( 813, 1270),
    ],
    // Rook
    [
        S( 444,  714), S( 435,  722), S( 444,  730), S( 447,  727), S( 466,  717), S( 482,  706), S( 457,  713), S( 486,  704),
        S( 425,  714), S( 423,  726), S( 444,  730), S( 465,  721), S( 450,  720), S( 482,  704), S( 467,  701), S( 500,  688),
        S( 404,  712), S( 426,  714), S( 429,  716), S( 432,  713), S( 463,  699), S( 467,  691), S( 506,  683), S( 481,  680),
        S( 387,  715), S( 400,  714), S( 405,  722), S( 414,  718), S( 420,  702), S( 421,  695), S( 431,  694), S( 433,  685),
        S( 366,  709), S( 369,  714), S( 381,  715), S( 393,  713), S( 394,  709), S( 379,  707), S( 405,  693), S( 393,  690),
        S( 359,  704), S( 370,  703), S( 379,  702), S( 378,  707), S( 385,  701), S( 382,  694), S( 419,  672), S( 395,  675),
        S( 356,  697), S( 369,  702), S( 385,  701), S( 382,  702), S( 387,  694), S( 389,  690), S( 407,  679), S( 374,  687),
        S( 376,  691), S( 378,  702), S( 389,  709), S( 394,  707), S( 398,  700), S( 387,  694), S( 405,  691), S( 379,  681),
    ],
    // Bishop
    [
        S( 297,  393), S( 278,  408), S( 289,  402), S( 248,  415), S( 260,  409), S( 275,  400), S( 310,  397), S( 267,  391),
        S( 315,  382), S( 339,  400), S( 334,  405), S( 318,  408), S( 348,  396), S( 346,  398), S( 335,  404), S( 327,  378),
        S( 330,  408), S( 353,  404), S( 354,  414), S( 378,  404), S( 365,  409), S( 397,  411), S( 373,  403), S( 361,  403),
        S( 319,  405), S( 336,  421), S( 357,  416), S( 369,  430), S( 365,  423), S( 360,  420), S( 335,  419), S( 320,  405),
        S( 314,  403), S( 326,  418), S( 335,  428), S( 354,  427), S( 352,  424), S( 335,  422), S( 327,  416), S( 322,  390),
        S( 324,  401), S( 333,  412), S( 331,  421), S( 336,  422), S( 336,  426), S( 331,  419), S( 334,  402), S( 337,  391),
        S( 328,  396), S( 328,  394), S( 341,  394), S( 317,  408), S( 326,  411), S( 337,  398), S( 345,  400), S( 331,  374),
        S( 303,  375), S( 327,  395), S( 307,  375), S( 300,  398), S( 304,  393), S( 303,  394), S( 327,  380), S( 316,  360),
    ],
    // Knight
    [
        S( 132,  292), S( 173,  358), S( 237,  378), S( 271,  367), S( 307,  371), S( 243,  348), S( 190,  360), S( 189,  270),
        S( 275,  356), S( 293,  377), S( 321,  383), S( 344,  382), S( 324,  377), S( 388,  359), S( 292,  373), S( 318,  339),
        S( 294,  369), S( 331,  386), S( 348,  404), S( 361,  405), S( 400,  388), S( 406,  379), S( 356,  377), S( 324,  358),
        S( 291,  383), S( 304,  404), S( 332,  417), S( 353,  419), S( 335,  419), S( 361,  414), S( 315,  404), S( 327,  373),
        S( 277,  383), S( 292,  395), S( 309,  418), S( 309,  419), S( 319,  423), S( 314,  410), S( 313,  395), S( 288,  375),
        S( 256,  367), S( 280,  388), S( 295,  397), S( 299,  412), S( 311,  411), S( 299,  393), S( 303,  381), S( 273,  368),
        S( 243,  359), S( 254,  375), S( 273,  385), S( 285,  387), S( 286,  385), S( 289,  381), S( 275,  364), S( 272,  369),
        S( 198,  350), S( 253,  334), S( 240,  368), S( 255,  369), S( 261,  370), S( 274,  359), S( 255,  341), S( 227,  345),
    ],
    // Pawn
    [
        S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0),
        S( 172,  310), S( 187,  313), S( 171,  307), S( 206,  254), S( 180,  253), S( 163,  262), S(  92,  317), S(  78,  315),
        S(  77,  152), S(  86,  167), S( 121,  116), S( 120,   80), S( 131,   76), S( 165,   92), S( 134,  146), S( 101,  133),
        S(  54,  134), S(  72,  139), S(  81,  114), S(  82,   96), S( 105,   97), S( 100,   99), S(  94,  129), S(  82,  109),
        S(  43,  116), S(  63,  128), S(  68,  108), S(  85,  103), S(  84,  104), S(  78,  104), S(  77,  121), S(  67,   98),
        S(  41,  111), S(  58,  125), S(  65,  108), S(  64,  112), S(  79,  114), S(  72,  108), S(  94,  116), S(  73,   94),
        S(  40,  115), S(  58,  127), S(  59,  116), S(  47,  111), S(  68,  124), S(  86,  110), S( 102,  115), S(  65,   95),
        S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0), S(   0,    0),
    ],
];

pub const PASSED_PAWN_BONUS: [PhasedScore; NumberOf::PASSED_PAWN_RANKS] = [
    S(-23, 10),
    S(7, 127),
    S(13, 61),
    S(-9, 37),
    S(-12, 13),
    S(-6, 8),
];

pub const DOUBLED_PAWN_VALUES: [PhasedScore; NumberOf::FILES] = [
    S(-14, -29),
    S(6, -25),
    S(-6, -16),
    S(-1, -6),
    S(-11, -3),
    S(-8, -17),
    S(-4, -30),
    S(-12, -40),
];

pub const ISOLATED_PAWN_VALUES: [PhasedScore; NumberOf::FILES] = [
    S(-3, -0),
    S(-10, -17),
    S(-21, -13),
    S(-19, -23),
    S(-21, -24),
    S(-14, -10),
    S(-14, -16),
    S(-12, 5),
];

const RANK_1: u8 = 1;

#[derive(Debug, Clone, Copy, Default)]
pub struct ByteKnightValues {}

impl EvalValues for ByteKnightValues {
    type ReturnScore = PhasedScore;

    fn psqt(&self, square: u8, piece: Piece, side: Side) -> Self::ReturnScore {
        PSQTS[piece as usize][square::flip_if(side == Side::White, square) as usize]
    }

    fn passed_pawn_bonus(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (_file, rank) = square::from_square(square::flip_if(side == Side::White, square));
        PASSED_PAWN_BONUS[(rank - RANK_1) as usize]
    }

    fn doubled_pawn_value(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (file, _rank) = square::from_square(square::flip_if(side == Side::White, square));
        DOUBLED_PAWN_VALUES[file as usize]
    }

    fn isolated_pawn_value(&self, square: u8, side: Side) -> Self::ReturnScore {
        let (file, _rank) = square::from_square(square::flip_if(side == Side::White, square));
        ISOLATED_PAWN_VALUES[file as usize]
    }
}
